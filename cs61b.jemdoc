# jemdoc: menu{MENU}{cs61b.html}
# jemdoc: analytics{UA-60586521-1}
= CS61B-Data Structures, Spring 2015

This are a series of guides related to CS61B. Some of these come from the mini-lectures that I have done in discussion, others are things I just write on the fly. I am always looking for feedback, so please contact me if you have any advice, comments, concerns, etc. on these guides.

== Inheritance
Java is an object oriented programming language. What does that mean? We have classes, which define a type of structure. We have things called objects, which are basically containers of data. All objects are an instance of some class. They have fields, which contain data and can interact with each other through methods.

So what is inheritance? Inheritance is a hierarchy of objects essentially. Basically, it defines a is-a relationship. So a simple example would be like this.

Let's say we have some class called Animal. Then we can have a subclass called Dog that inherits from Animal. All Dogs are Animals. Not all Animals are Dog. Anything an Animal can do, a Dog can go and better. So let's say we have these snippets of Java code

~~~
{}{}
public class Animal {
	public int legs;	

	public void move() {
		System.out.println("Animals move.");
	}

}

public class Dog extends Animal {
	public String breed;

	public void move() {
		System.out.println("Dogs can move too.");
	}

	public void bark() {
		System.out.println("Hi I'm a " + breed);
	}

}

~~~

So Dog is a subclass of Animal. It inherits from Animal and has everything that Animal has. Notice how we didn't redeclare the legs field. That doesn't mean that a Dog doesn't have legs. It does because it inherits it. Also we have overridden move in the subclass. That means when you have a Dog, it'll move like how a Dog should move, not how a generic Animal would. Dogs can also bark and have a breed, while Animals cannot. So like I said, Dogs are not only Animals, they are more.

This is a pretty cursory glance at inheritance. You can get a much better understanding from the Java documentation.

== Static and Dynamic Type
This is a topic that students always have troubles with. What is static and what is dynamic type in Java and what are the implications. Let's say we have this line of code

~~~
{}{}
	Animal a = new Dog();
~~~


== The Java Compiler and Casting

== Abstract Data Types (ADTs)

== Encapsulation

== Java Packages

== Generics
As we're writing Java code, we are in the position where we want to make it as flexible as possible. That's why we introduce generics. For 61B, you'll be using generics a lot. First of all, you'll be using generics when you are using someone else's generic libraries, such as the Java built-in libraries, or the Princeton Standard Library. You'll also be in the position where you are the library writer and must make your own code flexible for when other people use it.
=== Using Generics
Using generics is pretty straightforward. We just need to specify the generic types. We can see this in the following example.
~~~
{}{}
import java.util.ArrayList;

public class BasicArrayList {
	public static void main(String[] args) {
		ArrayList<String> L = new Arraylist<String>();
		L.add("potato");
		L.add("ketchup");
		String first = L.get(0);
	}
}
~~~

An Arraylist is one of the many data structures from the Java library that uses generics. When we specify the type of the generic to be String in the above example, the ArrayList now becomes an ArrayList specifically for Strings. Note that we cannot use primitives like ints for the type of a generic. You will have to use the Java wrapper classes, like Integer.

=== Implementing Something Generic
A lot of people can get confused on how to make a generic class. The syntax can be a bit intense, but it is manageable.

Let's start with the usual ways to specify generic types. We have:

- E for element
- K for key
- V for value
- T for type

Each of these plays into different data structures and will be used so. So how are we going to use them. Let's look at an example from lecture

~~~
{}{}
public class Vessel<E> {

	public void put(E x)
	public E peek()

}
~~~

I'm not really interested in the implementation as much as I am with what the signatures are. We have here a Vessel class that is mean to store things. We want to make it generic so that way if someone wants to take our code and use it to store things, then they should be allowed to store whatever they want. We see that in the class declaration, we included the formal type. Basically, it's like a dummy variable in math. Whenever someone uses our class specifies the actual generic types, it's like substituting the variable out for the actual type. Once we declared the formal types, we can then use it throughout the class, as seen in the code snippet above. E's are everywhere.

Now what we saw before was making the class itself generic. Now what about the case where we want to also be able to take in something generic.

~~~
{}{}
public class VesselHelper {

	public static <T> T remove(Vessel<T> v)

}
~~~

The method declaration for this is a bit different. Here we have a method remove that wants to take in a generic method and remove stuff from it. We once again have stuff in <>. This is the formal type declaration. It's telling Java that for this method, T is a dummy variable. Compare this to if we had something like this

~~~
{}{}
	public static T remove(Vessel<T> v)
~~~

This is different. Here we're saying that there is an actual class called T and that this remove method is specialized to remove from Vessels that contain T. That's different from saying that T is a dummy variable that should be replaced by something else

Finally for our class, you'll be seeing upper bounds and wildcards. When we use generics, at times we want to limit how generic it can actually be. For example, if you have a method that needs to do comparing, you'll probably want to limit the generic to comparables. That's when upper bounds come in. If you use an upper bound, then the person must put in something that is or is a subclass of the bound. 

You may also have wildcards. This is for when you're making a method that takes in generics and you might be taking in more than one generic thing. Let's say that you didn't care what they were. Then you can just use a wildcard. You can also bound wildcards to be of a certain type. Not that you cannot declare something as a wildcard or return a wildcard. It doesn't make sense.

~~~
{Complete VesselHelper}{}
public class VesselHelper {	

	public static <T> T remove(Vessel<T> v)
	public static <T extends Comparable<T>> T max(Vessel<T> x, Vessel<T> y)
	public static double ratio(Vessel<? extends Number> x, Vessel<? extends Number> y)

}
~~~

== Asymptotics

Coming after Tuesday's (3/10) discussion section. Probably the night of. If it's not, please bother me to update.
