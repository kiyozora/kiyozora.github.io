# jemdoc: menu{MENU}{cs61b.html}
# jemdoc: analytics{UA-60586521-1}
= CS61B-Data Structures, Spring 2015

This are a series of guides related to CS61B. Some of these come from the mini-lectures that I have done in discussion, others are things I just write on the fly. I am always looking for feedback, so please contact me if you have any advice, comments, concerns, etc. on these guides.

== Inheritance
Java is an object oriented programming language. What does that mean? We have classes, which define a type of structure. We have things called objects, which are basically containers of data. All objects are an instance of some class. They have fields, which contain data and can interact with each other through methods.

So what is inheritance? Inheritance is a hierarchy of objects essentially. Basically, it defines a is-a relationship. So a simple example would be like this.

Let's say we have some class called Animal. Then we can have a subclass called Dog that inherits from Animal. All Dogs are Animals. Not all Animals are Dog. Anything an Animal can do, a Dog can go and better. So let's say we have these snippets of Java code

~~~
{}{}
public class Animal {
	public int legs;	

	public void move() {
		System.out.println("Animals move.");
	}

}

public class Dog extends Animal {
	public String breed;

	public void move() {
		System.out.println("Dogs can move too.");
	}

	public void bark() {
		System.out.println("Hi I'm a " + breed);
	}

}

~~~

So Dog is a subclass of Animal. It inherits from Animal and has everything that Animal has. Notice how we didn't redeclare the legs field. That doesn't mean that a Dog doesn't have legs. It does because it inherits it. Also we have overridden move in the subclass. That means when you have a Dog, it'll move like how a Dog should move, not how a generic Animal would. Dogs can also bark and have a breed, while Animals cannot. So like I said, Dogs are not only Animals, they are more.

This is a pretty cursory glance at inheritance. You can get a much better understanding from the Java documentation.

== Static and Dynamic Type
This is a topic that students always have troubles with. What is static and what is dynamic type in Java and what are the implications. Let's say we have this line of code

~~~
{}{}
	Animal a = new Dog();
~~~


== The Java Compiler and Casting

== Abstract Data Types (ADTs)

== Encapsulation

== Java Packages

== Generics
As we're writing Java code, we are in the position where we want to make it as flexible as possible. That's why we introduce generics. For 61B, you'll be using generics a lot. First of all, you'll be using generics when you are using someone else's generic libraries, such as the Java built-in libraries, or the Princeton Standard Library. You'll also be in the position where you are the library writer and must make your own code flexible for when other people use it.
=== Using Generics
Using generics is pretty straightforward. We just need to specify the generic types. We can see this in the following example.
~~~
{}{}
import java.util.ArrayList;

public class BasicArrayList {
	public static void main(String[] args) {
		ArrayList<String> L = new Arraylist<String>();
		L.add("potato");
		L.add("ketchup");
		String first = L.get(0);
	}
}
~~~

An Arraylist is one of the many data structures from the Java library that uses generics. When we specify the type of the generic to be String in the above example, the ArrayList now becomes an ArrayList specifically for Strings. Note that we cannot use primitives like ints for the type of a generic. You will have to use the Java wrapper classes, like Integer.

=== Implementing Something Generic
A lot of people can get confused on how to make a generic class. The syntax can be a bit intense, but it is manageable.

Let's start with the usual ways to specify generic types. We have:

- E for element
- K for key
- V for value
- T for type

Each of these plays into different data structures and will be used so. So how are we going to use them. Let's look at an example from lecture

~~~
{}{}
public class Vessel<E> {

	public void put(E x)
	public E peek()

}
~~~

I'm not really interested in the implementation as much as I am with what the signatures are. We have here a Vessel class that is mean to store things. We want to make it generic so that way if someone wants to take our code and use it to store things, then they should be allowed to store whatever they want. We see that in the class declaration, we included the formal type. Basically, it's like a dummy variable in math. Whenever someone uses our class specifies the actual generic types, it's like substituting the variable out for the actual type. Once we declared the formal types, we can then use it throughout the class, as seen in the code snippet above. E's are everywhere.

Now what we saw before was making the class itself generic. Now what about the case where we want to also be able to take in something generic.

~~~
{}{}
public class VesselHelper {

	public static <T> T remove(Vessel<T> v)

}
~~~

The method declaration for this is a bit different. Here we have a method remove that wants to take in a generic method and remove stuff from it. We once again have stuff in <>. This is the formal type declaration. It's telling Java that for this method, T is a dummy variable. Compare this to if we had something like this

~~~
{}{}
	public static T remove(Vessel<T> v)
~~~

This is different. Here we're saying that there is an actual class called T and that this remove method is specialized to remove from Vessels that contain T. That's different from saying that T is a dummy variable that should be replaced by something else

Finally for our class, you'll be seeing upper bounds and wildcards. When we use generics, at times we want to limit how generic it can actually be. For example, if you have a method that needs to do comparing, you'll probably want to limit the generic to comparables. That's when upper bounds come in. If you use an upper bound, then the person must put in something that is or is a subclass of the bound. 

You may also have wildcards. This is for when you're making a method that takes in generics and you might be taking in more than one generic thing. Let's say that you didn't care what they were. Then you can just use a wildcard. You can also bound wildcards to be of a certain type. Not that you cannot declare something as a wildcard or return a wildcard. It doesn't make sense.

~~~
{Complete VesselHelper}{}
public class VesselHelper {	

	public static <T> T remove(Vessel<T> v)
	public static <T extends Comparable<T>> T max(Vessel<T> x, Vessel<T> y)
	public static double ratio(Vessel<? extends Number> x, Vessel<? extends Number> y)

}
~~~

== Asymptotics

Coming after Tuesday's (3//10) discussion section. Probably the night of. If it's not, please bother me to update.

== Serializable

== Hashing

== Heaps

Sometimes when we are storing things, when we want to get something back, we want something with the highest priority, or maybe the smallest priority. There's this notion that things can be compared and that we want the smallest or biggest thing. The data structure that support this is called a priority queue. As we've seen before queues are a type of disabled list, with FIFO (First in, first out) properites. A priority queue will be thing with the priority we want will get out first, whether it be the smallest or the largest.

There are different ways to actually implement priority queues. The way that we see here is a heap. There are two types of heaps, min-heaps and max-heaps. min-heaps will return you the smallest thing in the heap, max-heaps, the largest. Heaps can be visualized as a complete binary tree with the heap property. Like the BST property, this is a recursive invariant. The heap property is that no child key is less than its parent's key. That also means that all of the subtrees in a heap are also heaps within themselves. As a reminder a complete binary tree is one where ever row is full except for the last row, which will be filled from left to right. 

What's nice about the fact that we're having a heap be a complete binary tree is that we can represent a heap with an array. That's nice because arrays are fast. We could do it with actual node and references, but arrays are faster in practice. So we will have each node in the tree map to an array index based on the level of the node in the tree. We leave index 0 of the array empty to help us with this bookkeeping. The root will be at index 1. Any aribitrary node's children will be at 2i and 2i\+1, where i is the index of the node. Why does this work? I suggest mulling on that fact for a bit for yourself.

Now getting the min itself is easy. It's just the thing at index 1, the thing at the root. The more interesting operations are inserting something into our heap and removing the min item. To insert something, we'll place is at the next free spot in the tree, at the right most index of the array (not index 0 though). But wait, doesn't this break the heap property? So what shall we do. We fix it of course, by bubbling up the entry until the heap property is maintainged again. That is, for a min-heap, while the key that we just inserted is less than its parent, we'll keep swapping it with its parent. How long will this take? Well in worst case, the item we inserted is the smallest item. That means that it must go all the way to the root. Since it's a complete binary tree, if we have N items in the heap, the height of the tree is $\lg(N)$. Thus insertion runs in $\Theta(\lg(n))$ time in worst case. In best case, we added a really large element to the heap, one that is bigger that its parent, so it will run in $\Theta(1)$ time in best case.

As for removal, we can just get rid of the root. But now we have a hole, so what should we fill it with. Well remember that we want a complete binary tree, so the only thing we can replace it with will be the last element in the tree. Once again we might have violated the heap property. So what will we do? Fix it, this time by bubbling down. While the key we used to replace the removed root is bigger than its child(ren), we will swap it. If it's only bigger than one of its children, we only have one choice to swap it with. If it's bigger than both of its children, then we will swap it with the smaller child. The runtime for this will be like for insertion, for similar reasons. 

I'll insert drawings sooner or later. Go ASCII art!

== A Review of Data Structures

~~~
{}{table}{dataStructures}
ADT | Lists | Sets | Maps | Priority Queues ||
Common and Efficient Implementations | Linked Lists, Array Lists | HashSets, TreeSets | HashMaps, Tree Maps | Heaps (Min/Max) ||
Use Cases in the Real World | Grocery Lists, Friend Lists on SNS | Class Rosters, Check what albums I have in my k-pop collection | Dictionaries, Table of Contents | To-do lists, Scheduling ||
Advantages | Items have order | No repeats, quick look up for existance | Mapping of Key-Value with quick look up | Gives priorities, there's a notion of best 
~~~
