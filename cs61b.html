<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="assets/css/jemdoc.css" type="text/css" />
<link href="assets/css/prettify.css" type="text/css" rel="stylesheet" />
<title>CS61BL Summer 2015-Data Structures and Programming Methodology</title>
<script type="text/javascript" src="assets/js/prettify.js"></script>
</head>
<body onload="prettyPrint()">
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
    var pageTracker = _gat._getTracker("UA-60586521-1");
    pageTracker._trackPageview();
} catch(err) {}</script>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-category">Daniel Nguyen</div>
<div class="menu-item"><a href="index.html">Home</a></div>
<div class="menu-item"><a href="cs61b.html" class="current">CS61B</a></div>
<div class="menu-item"><a href="Resume.pdf">Resume</a></div>
<div class="menu-item"><a href="https://github.com/kiyozora">Github</a></div>
</td>
<td id="layout-content">
<div id="toptitle">
<h1>CS61BL Summer 2015-Data Structures and Programming Methodology</h1>
</div>
<p>This are a series of guides related to CS61B/CS61BL. Some of these come from the mini-lectures that I have done in discussion, others are things I just write on the fly. I am always looking for feedback, so please contact me if you have any advice, comments, concerns, etc. on these guides.</p>
<h2>Table of Contents</h2>
<ul>
<li><p><a href="cs61b/inheritance.html">Inheritance</a></p>
</li>
<li><p><a href="cs61b/generics.html">Generics</a></p>
</li>
<li><p><a href="cs61b/heaps.html">Heaps</a></p>
</li>
</ul>
<h2>The Java Compiler and Casting</h2>
<h2>Abstract Data Types (ADTs)</h2>
<h2>Encapsulation</h2>
<h2>Java Packages</h2>
<h2>Asymptotics</h2>
<p>Coming after Tuesday's (3<i></i>10) discussion section. Probably the night of. If it's not, please bother me to update.</p>
<h2>Serializable</h2>
<h2>Hashing</h2>
<h2>Heaps</h2>
<p>Sometimes when we are storing things, when we want to get something back, we want something with the highest priority, or maybe the smallest priority. There's this notion that things can be compared and that we want the smallest or biggest thing. The data structure that support this is called a priority queue. As we've seen before queues are a type of disabled list, with FIFO (First in, first out) properites. A priority queue will be thing with the priority we want will get out first, whether it be the smallest or the largest.</p>
<p>There are different ways to actually implement priority queues. The way that we see here is a heap. There are two types of heaps, min-heaps and max-heaps. min-heaps will return you the smallest thing in the heap, max-heaps, the largest. Heaps can be visualized as a complete binary tree with the heap property. Like the BST property, this is a recursive invariant. The heap property is that no child key is less than its parent's key. That also means that all of the subtrees in a heap are also heaps within themselves. As a reminder a complete binary tree is one where ever row is full except for the last row, which will be filled from left to right. </p>
<p>What's nice about the fact that we're having a heap be a complete binary tree is that we can represent a heap with an array. That's nice because arrays are fast. We could do it with actual node and references, but arrays are faster in practice. So we will have each node in the tree map to an array index based on the level of the node in the tree. We leave index 0 of the array empty to help us with this bookkeeping. The root will be at index 1. Any aribitrary node's children will be at 2i and 2i+1, where i is the index of the node. Why does this work? I suggest mulling on that fact for a bit for yourself.</p>
<p>Now getting the min itself is easy. It's just the thing at index 1, the thing at the root. The more interesting operations are inserting something into our heap and removing the min item. To insert something, we'll place is at the next free spot in the tree, at the right most index of the array (not index 0 though). But wait, doesn't this break the heap property? So what shall we do. We fix it of course, by bubbling up the entry until the heap property is maintainged again. That is, for a min-heap, while the key that we just inserted is less than its parent, we'll keep swapping it with its parent. How long will this take? Well in worst case, the item we inserted is the smallest item. That means that it must go all the way to the root. Since it's a complete binary tree, if we have N items in the heap, the height of the tree is <img class="eq" src="assets/eqs/9090659312048392276-130.png" alt="lg(N)" style="vertical-align: -5px" />. Thus insertion runs in <img class="eq" src="assets/eqs/7400715617863922135-130.png" alt="Theta(lg(n))" style="vertical-align: -5px" /> time in worst case. In best case, we added a really large element to the heap, one that is bigger that its parent, so it will run in <img class="eq" src="assets/eqs/8702373264529792381-130.png" alt="Theta(1)" style="vertical-align: -5px" /> time in best case.</p>
<p>As for removal, we can just get rid of the root. But now we have a hole, so what should we fill it with. Well remember that we want a complete binary tree, so the only thing we can replace it with will be the last element in the tree. Once again we might have violated the heap property. So what will we do? Fix it, this time by bubbling down. While the key we used to replace the removed root is bigger than its child(ren), we will swap it. If it's only bigger than one of its children, we only have one choice to swap it with. If it's bigger than both of its children, then we will swap it with the smaller child. The runtime for this will be like for insertion, for similar reasons. </p>
<p>I'll insert drawings sooner or later. Go ASCII art!</p>
<h2>A Review of Data Structures</h2>
<p>Data structures was probably one of the most influential reasons why I become a CS major. I had an amazing experience when I took my data structures class. One of the questions I get asked a lot is then, what the hell is a data structure.</p>
<p>Well Wikipedia says that it's a way of organizing data so it can be used efficiently. But that's so boring. I think of it like this. We're living in a generation where data is everywhere. There's records on how many hairs you've got on your head to the distance to the farthest star you can see and blah blah, the list is endless. It's an amazing time we're living in. It's also a chaotic time because we have all of this information and what the hell are we going to do with it. Well, that's where data structures come in. It's a way of bring order to the chaos of data that we have so that way it's usable. With the amounts of data we have, making it usable it amazing enough. Making it that it's usable in a way that we get results before the heat death of the universe is a miracle. That's what a data structure is to me, and maybe I just have a tendency to make it more impressive than it actually is.</p>
<p>We've seen a lot of data structures in this class. I've organized it into the table below.</p>
<table id="dataStructures">
<tr class="r1"><td class="c1">ADT </td><td class="c2"> Lists </td><td class="c3"> Sets </td><td class="c4"> Maps </td><td class="c5"> Priority Queues </td><td class="c6"> Graphs </td></tr>
<tr class="r2"><td class="c1">Common and Efficient Implementations </td><td class="c2"> Linked Lists, Array Lists </td><td class="c3"> HashSets, TreeSets </td><td class="c4"> HashMaps, Tree Maps </td><td class="c5"> Heaps (Min/Max) </td><td class="c6"> </td></tr>
<tr class="r3"><td class="c1">Use Cases in the Real World </td><td class="c2"> Grocery Lists, Friend Lists on SNS </td><td class="c3"> Class Rosters, Check what albums I have in my k-pop collection </td><td class="c4"> Dictionaries, Table of Contents </td><td class="c5"> To-do lists, Scheduling </td><td class="c6"> </td></tr>
<tr class="r4"><td class="c1">Advantages </td><td class="c2"> Items have order </td><td class="c3"> No repeats, quick look up for existance </td><td class="c4"> Mapping of Key-Value with quick look up </td><td class="c5"> Gives priorities, there's a notion of best </td><td class="c6"> 
</td></tr></table>
<ul>
<li><p>Lists</p>
<ul>
<li><p>Linked Lists</p>
</li>
<li><p>Array Lists</p>
</li></ul>
</li>
<li><p>Sets</p>
<ul>
<li><p>HashSets</p>
</li>
<li><p>TreeSets</p>
</li></ul>
</li>
<li><p>Maps</p>
<ul>
<li><p>HashMaps</p>
</li>
<li><p>TreeMaps</p>
</li></ul>
</li>
<li><p>Priority Queues</p>
<ul>
<li><p>Heaps</p>
</li></ul>
</li>
<li><p>Graphs</p>
</li>
</ul>
<div id="footer">
<div id="footer-text">
Page generated 2015-06-20 02:31:24 PDT, by <a href="http://jemdoc.jaboc.net/">jemdoc</a>.
</div>
</div>
</td>
</tr>
</table>
</body>
</html>
